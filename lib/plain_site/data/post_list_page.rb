#coding:utf-8
module PlainSite;end
module PlainSite::Data
    require 'ostruct'
    # PostList Pagination
    class PostListPage<OpenStruct
        # These attributes' accessor are auto  generated by OpenStruct
        # attr_reader(
        #    :nos,:slug,:display_num,
        #    :posts,:prev_page,:next_page,
        #    :total_pages_count,:total_posts_count,:page_size,:all_pages,
        #    :revert_nos,:site
        # )
        # attr_writer :prev_page,:next_page,:all_pages # set after create

        # Options:
        # nos - The Integer page number
        # slug - The String page name suggest to used in url,first page is 'index',others are random string
        # display_num - The Integer always be ascending,first page is 1,second page is 2
        # posts - The PostList
        # prev_page - The PostListPage previous of self
        # next_page - The PostListPage next of self
        # total_pages_count - The Integer of total count in this pagination
        # total_posts_count - The Integer of total count in this pagination
        # page_size - The Integer of preset page size
        # revert_nos - The Boolean indicate if this post list page use revert nos.
        #               When false case,it's html page must be regenerated every time.
        # site - The Site belongs to
        def initialize(opts)
            super opts
        end

        # The String page order name should be used in url(if you want to use revert num in page url)
        # Example,in revert_nos case,
        # if total_pages is 6,first page's nos is 6,last page's nos is 1,
        # first page's slug is 'index',second page is '5'
        def slug_nos
            @prev_page ? @nos.to_s : 'index'
        end

        # The String url for self page
        def url
            site.url_for self
        end

        # Remove posts,resort all previous pages
        # list - The String[] of post's path list
        def remove(list)
            posts=posts.select do |p|
                list.include? p.path
            end
            try_pad_from_other_page
        end

        # Pop posts
        # Return Post[]
        def pop_multi(n)
            ret=posts.slice(-n,n)
            posts=posts.slice(0,-n-1)
            ret
        end

        def try_pad_from_other_page
            n=page_size-posts.length
            return [] unless n>0
            related_pages=[self]
            if prev_page
                posts=prev_page.posts.pop_multi(n)+posts
                related_pages.concat prev_page.try_pad_from_other_page
            elsif next_page
                posts+=next_page.posts.take n
            end
            related_pages
        end


        # See PostList#include?
        def include?(a)
            posts.include? a
        end

    end
end
